<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Dcel Data Structure: Riferimenti per la classe Dcel::Vertex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dcel Data Structure
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Pagina&#160;Principale</span></a></li>
      <li><a href="pages.html"><span>Pagine&#160;collegate</span></a></li>
      <li><a href="namespaces.html"><span>Namespace</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classi</span></a></li>
      <li><a href="files.html"><span>File</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Cerca" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Elenco&#160;dei&#160;tipi&#160;composti</span></a></li>
      <li><a href="classes.html"><span>Indice&#160;dei&#160;tipi&#160;composti</span></a></li>
      <li><a href="hierarchy.html"><span>Gerarchia&#160;delle&#160;classi</span></a></li>
      <li><a href="functions.html"><span>Membri&#160;dei&#160;composti</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDcel_1_1Vertex.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Composti</a> &#124;
<a href="#pub-methods">Membri pubblici</a> &#124;
<a href="#pro-methods">Membri protetti</a> &#124;
<a href="#pro-attribs">Attributi protetti</a> &#124;
<a href="#friends">Friend</a> &#124;
<a href="classDcel_1_1Vertex-members.html">Elenco di tutti i membri</a>  </div>
  <div class="headertitle">
<div class="title">Riferimenti per la classe Dcel::Vertex</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classe rappresentante un vertice della DCEL.  
 <a href="classDcel_1_1Vertex.html#details">Continua...</a></p>

<p><code>#include &lt;<a class="el" href="dcel__vertex_8h_source.html">dcel_vertex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Composti</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sui vertici adiacenti ad un vertice.  <a href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l'immutabilità.  <a href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sulle facce incidenti su un vertice.  <a href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice.  <a href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l'immutabilità.  <a href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l'immutabilità.  <a href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sulle facce incidenti su un vertice.  <a href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice.  <a href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge entranti in un vertice.  <a href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge uscenti da un vertice.  <a href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Membri pubblici</h2></td></tr>
<tr class="memitem:a2da229e7ef9443810ec4f61da9a33e76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a2da229e7ef9443810ec4f61da9a33e76">Vertex</a> ()</td></tr>
<tr class="memdesc:a2da229e7ef9443810ec4f61da9a33e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#a2da229e7ef9443810ec4f61da9a33e76">Continua...</a><br /></td></tr>
<tr class="separator:a2da229e7ef9443810ec4f61da9a33e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da5e567cfaf3d1d4c9a3dfecf13564"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ad3da5e567cfaf3d1d4c9a3dfecf13564">Vertex</a> (const <a class="el" href="classPoint.html">Pointd</a> &amp;p)</td></tr>
<tr class="memdesc:ad3da5e567cfaf3d1d4c9a3dfecf13564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#ad3da5e567cfaf3d1d4c9a3dfecf13564">Continua...</a><br /></td></tr>
<tr class="separator:ad3da5e567cfaf3d1d4c9a3dfecf13564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aaedc4b3477ed85390daa341f3976e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a31aaedc4b3477ed85390daa341f3976e">Vertex</a> (const <a class="el" href="classPoint.html">Pointd</a> &amp;p, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *halfEdge)</td></tr>
<tr class="memdesc:a31aaedc4b3477ed85390daa341f3976e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#a31aaedc4b3477ed85390daa341f3976e">Continua...</a><br /></td></tr>
<tr class="separator:a31aaedc4b3477ed85390daa341f3976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eb006d5da7901f5cbc5f103e919a0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a58eb006d5da7901f5cbc5f103e919a0f">Vertex</a> (const <a class="el" href="classPoint.html">Pointd</a> &amp;p, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *halfEdge, int <a class="el" href="classDcel_1_1Vertex.html#a532c8cd4a47dc77aa49142d74024a964">cardinality</a>)</td></tr>
<tr class="memdesc:a58eb006d5da7901f5cbc5f103e919a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#a58eb006d5da7901f5cbc5f103e919a0f">Continua...</a><br /></td></tr>
<tr class="separator:a58eb006d5da7901f5cbc5f103e919a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f736bd9320adb06315ba1c7a12f1f87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a3f736bd9320adb06315ba1c7a12f1f87">~Vertex</a> ()</td></tr>
<tr class="memdesc:a3f736bd9320adb06315ba1c7a12f1f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distruttore vuoto.  <a href="#a3f736bd9320adb06315ba1c7a12f1f87">Continua...</a><br /></td></tr>
<tr class="separator:a3f736bd9320adb06315ba1c7a12f1f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aa7c2ed2b5a65a46a5411cd567e7ac"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac2aa7c2ed2b5a65a46a5411cd567e7ac">getId</a> () const </td></tr>
<tr class="memdesc:ac2aa7c2ed2b5a65a46a5411cd567e7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restirìtuisce l'id identificativo nella <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> del vertice.  <a href="#ac2aa7c2ed2b5a65a46a5411cd567e7ac">Continua...</a><br /></td></tr>
<tr class="separator:ac2aa7c2ed2b5a65a46a5411cd567e7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7de167d0c3c9ce68a771506ed75d76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#adb7de167d0c3c9ce68a771506ed75d76">getFlag</a> () const </td></tr>
<tr class="memdesc:adb7de167d0c3c9ce68a771506ed75d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il flag associato al vertice.  <a href="#adb7de167d0c3c9ce68a771506ed75d76">Continua...</a><br /></td></tr>
<tr class="separator:adb7de167d0c3c9ce68a771506ed75d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6886ddfb802b2411fe4b02ff35fa2e2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a6886ddfb802b2411fe4b02ff35fa2e2d">getNormal</a> () const </td></tr>
<tr class="memdesc:a6886ddfb802b2411fe4b02ff35fa2e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il vettore normale al vertice.  <a href="#a6886ddfb802b2411fe4b02ff35fa2e2d">Continua...</a><br /></td></tr>
<tr class="separator:a6886ddfb802b2411fe4b02ff35fa2e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955f92ea4027d02503c7714de9af742b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Pointd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a955f92ea4027d02503c7714de9af742b">getCoordinate</a> () const </td></tr>
<tr class="memdesc:a955f92ea4027d02503c7714de9af742b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce le coordinate del vertice.  <a href="#a955f92ea4027d02503c7714de9af742b">Continua...</a><br /></td></tr>
<tr class="separator:a955f92ea4027d02503c7714de9af742b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20318e5baac00d992e7a98c46d19d7ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a20318e5baac00d992e7a98c46d19d7ac">getCardinality</a> () const </td></tr>
<tr class="memdesc:a20318e5baac00d992e7a98c46d19d7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il numero di edge incidenti sul vertice.  <a href="#a20318e5baac00d992e7a98c46d19d7ac">Continua...</a><br /></td></tr>
<tr class="separator:a20318e5baac00d992e7a98c46d19d7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d809eb8575c715b32d51f5bb5393354"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a9d809eb8575c715b32d51f5bb5393354">getIncidentHalfEdge</a> () const </td></tr>
<tr class="memdesc:a9d809eb8575c715b32d51f5bb5393354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il puntatore l'half edge costante incidente sul vertice.  <a href="#a9d809eb8575c715b32d51f5bb5393354">Continua...</a><br /></td></tr>
<tr class="separator:a9d809eb8575c715b32d51f5bb5393354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f71d2e2ae4a12b34dd155c7e85a3d1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a12f71d2e2ae4a12b34dd155c7e85a3d1">dist</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *otherVertex) const </td></tr>
<tr class="memdesc:a12f71d2e2ae4a12b34dd155c7e85a3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce la distanza tra il vertice this e il vertice in input.  <a href="#a12f71d2e2ae4a12b34dd155c7e85a3d1">Continua...</a><br /></td></tr>
<tr class="separator:a12f71d2e2ae4a12b34dd155c7e85a3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d164730ab1cb90d87f80c43ac25bc4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a6d164730ab1cb90d87f80c43ac25bc4a">operator==</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> &amp;otherVertex) const </td></tr>
<tr class="memdesc:a6d164730ab1cb90d87f80c43ac25bc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operatore di uguaglianza tra vertici.  <a href="#a6d164730ab1cb90d87f80c43ac25bc4a">Continua...</a><br /></td></tr>
<tr class="separator:a6d164730ab1cb90d87f80c43ac25bc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf34479e1a7c60b032e45b62fdf5145"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7bf34479e1a7c60b032e45b62fdf5145">operator!=</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> &amp;othervertex) const </td></tr>
<tr class="memdesc:a7bf34479e1a7c60b032e45b62fdf5145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operatore di disuguaglianza tra vertici.  <a href="#a7bf34479e1a7c60b032e45b62fdf5145">Continua...</a><br /></td></tr>
<tr class="separator:a7bf34479e1a7c60b032e45b62fdf5145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6b523e517664a4f2c5d84d07c7539a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe6b523e517664a4f2c5d84d07c7539a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afe6b523e517664a4f2c5d84d07c7539a">setFlag</a> ()</td></tr>
<tr class="memdesc:afe6b523e517664a4f2c5d84d07c7539a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag del vertice a 1. <br /></td></tr>
<tr class="separator:afe6b523e517664a4f2c5d84d07c7539a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1478717bb5e45383acc6531c420dd57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa1478717bb5e45383acc6531c420dd57">setFlag</a> (int newFlag)</td></tr>
<tr class="memdesc:aa1478717bb5e45383acc6531c420dd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag del vertice.  <a href="#aa1478717bb5e45383acc6531c420dd57">Continua...</a><br /></td></tr>
<tr class="separator:aa1478717bb5e45383acc6531c420dd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac289a84581b998d13634f2aafd977d5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac289a84581b998d13634f2aafd977d5b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac289a84581b998d13634f2aafd977d5b">resetFlag</a> ()</td></tr>
<tr class="memdesc:ac289a84581b998d13634f2aafd977d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag della faccia a 0. <br /></td></tr>
<tr class="separator:ac289a84581b998d13634f2aafd977d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7e992ed35ffdfdc24b37f8d6fc2386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7b7e992ed35ffdfdc24b37f8d6fc2386">setNormal</a> (const <a class="el" href="classPoint.html">Vec3</a> &amp;newNormal)</td></tr>
<tr class="memdesc:a7b7e992ed35ffdfdc24b37f8d6fc2386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il vettore normale al vertice.  <a href="#a7b7e992ed35ffdfdc24b37f8d6fc2386">Continua...</a><br /></td></tr>
<tr class="separator:a7b7e992ed35ffdfdc24b37f8d6fc2386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9711522bca5e434f38a4dd693472017c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a9711522bca5e434f38a4dd693472017c">setCoordinate</a> (const <a class="el" href="classPoint.html">Pointd</a> &amp;newCoordinate)</td></tr>
<tr class="memdesc:a9711522bca5e434f38a4dd693472017c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta le coordinate del vertice.  <a href="#a9711522bca5e434f38a4dd693472017c">Continua...</a><br /></td></tr>
<tr class="separator:a9711522bca5e434f38a4dd693472017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6c739192c444e8965949e79041c1d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a9e6c739192c444e8965949e79041c1d1">setCardinality</a> (int newCardinality)</td></tr>
<tr class="memdesc:a9e6c739192c444e8965949e79041c1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta la cardinalità del vertice.  <a href="#a9e6c739192c444e8965949e79041c1d1">Continua...</a><br /></td></tr>
<tr class="separator:a9e6c739192c444e8965949e79041c1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0756749e0c536697faf1ae826d133d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#adc0756749e0c536697faf1ae826d133d">decrementCardinality</a> ()</td></tr>
<tr class="memdesc:adc0756749e0c536697faf1ae826d133d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrementa la cardinalità del vertice (se essa è maggiore di 0)  <a href="#adc0756749e0c536697faf1ae826d133d">Continua...</a><br /></td></tr>
<tr class="separator:adc0756749e0c536697faf1ae826d133d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8c450e431fd8babcdb7cfdf517b8fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7d8c450e431fd8babcdb7cfdf517b8fa">incrementCardinality</a> ()</td></tr>
<tr class="memdesc:a7d8c450e431fd8babcdb7cfdf517b8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incrementa la cardinalità del vertice.  <a href="#a7d8c450e431fd8babcdb7cfdf517b8fa">Continua...</a><br /></td></tr>
<tr class="separator:a7d8c450e431fd8babcdb7cfdf517b8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a949ee8a2fcace2c112238586f13daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a0a949ee8a2fcace2c112238586f13daf">getIncidentHalfEdge</a> ()</td></tr>
<tr class="memdesc:a0a949ee8a2fcace2c112238586f13daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il puntatore all'half edge incidente sul vertice.  <a href="#a0a949ee8a2fcace2c112238586f13daf">Continua...</a><br /></td></tr>
<tr class="separator:a0a949ee8a2fcace2c112238586f13daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4e583a30166edb3cac283bb60b4191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7c4e583a30166edb3cac283bb60b4191">setIncidentHalfEdge</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *newIncidentHalfEdge)</td></tr>
<tr class="memdesc:a7c4e583a30166edb3cac283bb60b4191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assegna un nuovo half edge incidente al vertice.  <a href="#a7c4e583a30166edb3cac283bb60b4191">Continua...</a><br /></td></tr>
<tr class="separator:a7c4e583a30166edb3cac283bb60b4191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5950ee3f62f57974b4a683d812e230"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ade5950ee3f62f57974b4a683d812e230">getNumberIncidentHalfEdges</a> () const </td></tr>
<tr class="memdesc:ade5950ee3f62f57974b4a683d812e230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce il numero di half edge (non di edge) incidenti sul vertice.  <a href="#ade5950ee3f62f57974b4a683d812e230">Continua...</a><br /></td></tr>
<tr class="separator:ade5950ee3f62f57974b4a683d812e230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3ab6e9eff11e64e01369ee2c7d2f6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afb3ab6e9eff11e64e01369ee2c7d2f6e">getNumberIncidentFaces</a> () const </td></tr>
<tr class="memdesc:afb3ab6e9eff11e64e01369ee2c7d2f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce il numero di facce incidenti sul vertice.  <a href="#afb3ab6e9eff11e64e01369ee2c7d2f6e">Continua...</a><br /></td></tr>
<tr class="separator:afb3ab6e9eff11e64e01369ee2c7d2f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238513dc5c1abcba58c9c1bdcc2e0db0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a238513dc5c1abcba58c9c1bdcc2e0db0">getNumberAdjacentVertices</a> () const </td></tr>
<tr class="memdesc:a238513dc5c1abcba58c9c1bdcc2e0db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce il numero di vertici adiacenti al vertice.  <a href="#a238513dc5c1abcba58c9c1bdcc2e0db0">Continua...</a><br /></td></tr>
<tr class="separator:a238513dc5c1abcba58c9c1bdcc2e0db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af03f5188824f4dacc0652eb52aabed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7af03f5188824f4dacc0652eb52aabed">findSharedHalfEdge</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *vertex) const </td></tr>
<tr class="memdesc:a7af03f5188824f4dacc0652eb52aabed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che cerca e restituisce l'half edge costante condiviso dal vertice this e vertex.  <a href="#a7af03f5188824f4dacc0652eb52aabed">Continua...</a><br /></td></tr>
<tr class="separator:a7af03f5188824f4dacc0652eb52aabed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e18f8229b78cf20a99adfa5b0a5b9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a1d8e18f8229b78cf20a99adfa5b0a5b9">toString</a> () const </td></tr>
<tr class="memdesc:a1d8e18f8229b78cf20a99adfa5b0a5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione toString di un vertice.  <a href="#a1d8e18f8229b78cf20a99adfa5b0a5b9">Continua...</a><br /></td></tr>
<tr class="separator:a1d8e18f8229b78cf20a99adfa5b0a5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67907af93aecf1439b371add6cfc789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac67907af93aecf1439b371add6cfc789">adjacentVertexBegin</a> () const </td></tr>
<tr class="memdesc:ac67907af93aecf1439b371add6cfc789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#ac67907af93aecf1439b371add6cfc789">Continua...</a><br /></td></tr>
<tr class="separator:ac67907af93aecf1439b371add6cfc789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0034fe1f7a6225950d1c6a0a6f9ffc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa0034fe1f7a6225950d1c6a0a6f9ffc4">adjacentVertexEnd</a> () const </td></tr>
<tr class="memdesc:aa0034fe1f7a6225950d1c6a0a6f9ffc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#aa0034fe1f7a6225950d1c6a0a6f9ffc4">Continua...</a><br /></td></tr>
<tr class="separator:aa0034fe1f7a6225950d1c6a0a6f9ffc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9976abbc083b7f343df09755639c4a6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a9976abbc083b7f343df09755639c4a6d">adjacentVertexBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const </td></tr>
<tr class="memdesc:a9976abbc083b7f343df09755639c4a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#a9976abbc083b7f343df09755639c4a6d">Continua...</a><br /></td></tr>
<tr class="separator:a9976abbc083b7f343df09755639c4a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab0fbec7249bcbd5d0be2a4551fd91c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afab0fbec7249bcbd5d0be2a4551fd91c">adjacentVertexBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const </td></tr>
<tr class="memdesc:afab0fbec7249bcbd5d0be2a4551fd91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#afab0fbec7249bcbd5d0be2a4551fd91c">Continua...</a><br /></td></tr>
<tr class="separator:afab0fbec7249bcbd5d0be2a4551fd91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9d5250d0248081d579fc8807272b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a92e9d5250d0248081d579fc8807272b1">adjacentVertexBegin</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start) const </td></tr>
<tr class="memdesc:a92e9d5250d0248081d579fc8807272b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#a92e9d5250d0248081d579fc8807272b1">Continua...</a><br /></td></tr>
<tr class="separator:a92e9d5250d0248081d579fc8807272b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedef3b927ff65391da2a19be06b0bb7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aedef3b927ff65391da2a19be06b0bb7e">adjacentVertexBegin</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start, const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *end) const </td></tr>
<tr class="memdesc:aedef3b927ff65391da2a19be06b0bb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#aedef3b927ff65391da2a19be06b0bb7e">Continua...</a><br /></td></tr>
<tr class="separator:aedef3b927ff65391da2a19be06b0bb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec54a206474159f5fbb91eaca3fca9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#acec54a206474159f5fbb91eaca3fca9c">outgoingHalfEdgeBegin</a> () const </td></tr>
<tr class="memdesc:acec54a206474159f5fbb91eaca3fca9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>.  <a href="#acec54a206474159f5fbb91eaca3fca9c">Continua...</a><br /></td></tr>
<tr class="separator:acec54a206474159f5fbb91eaca3fca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e864a3d65ecfcefc12f9a623ab422c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a79e864a3d65ecfcefc12f9a623ab422c">outgoingHalfEdgeEnd</a> () const </td></tr>
<tr class="memdesc:a79e864a3d65ecfcefc12f9a623ab422c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>.  <a href="#a79e864a3d65ecfcefc12f9a623ab422c">Continua...</a><br /></td></tr>
<tr class="separator:a79e864a3d65ecfcefc12f9a623ab422c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb09e3d8ec23f60ddc83b6cf1397de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a2eb09e3d8ec23f60ddc83b6cf1397de9">outgoingHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const </td></tr>
<tr class="memdesc:a2eb09e3d8ec23f60ddc83b6cf1397de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>.  <a href="#a2eb09e3d8ec23f60ddc83b6cf1397de9">Continua...</a><br /></td></tr>
<tr class="separator:a2eb09e3d8ec23f60ddc83b6cf1397de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0c5d03b6fb48c1d4deb997601aab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a67b0c5d03b6fb48c1d4deb997601aab6">outgoingHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const </td></tr>
<tr class="memdesc:a67b0c5d03b6fb48c1d4deb997601aab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>.  <a href="#a67b0c5d03b6fb48c1d4deb997601aab6">Continua...</a><br /></td></tr>
<tr class="separator:a67b0c5d03b6fb48c1d4deb997601aab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112e7a8607dcee8f8bfc286cba7765d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a112e7a8607dcee8f8bfc286cba7765d3">incomingHalfEdgeBegin</a> () const </td></tr>
<tr class="memdesc:a112e7a8607dcee8f8bfc286cba7765d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>.  <a href="#a112e7a8607dcee8f8bfc286cba7765d3">Continua...</a><br /></td></tr>
<tr class="separator:a112e7a8607dcee8f8bfc286cba7765d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb497fcab1ac5e9ab2ccadbabed10c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#abb497fcab1ac5e9ab2ccadbabed10c37">incomingHalfEdgeEnd</a> () const </td></tr>
<tr class="memdesc:abb497fcab1ac5e9ab2ccadbabed10c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>.  <a href="#abb497fcab1ac5e9ab2ccadbabed10c37">Continua...</a><br /></td></tr>
<tr class="separator:abb497fcab1ac5e9ab2ccadbabed10c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c99dc290f1b17caea402f461e2ce15e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a5c99dc290f1b17caea402f461e2ce15e">incomingHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const </td></tr>
<tr class="memdesc:a5c99dc290f1b17caea402f461e2ce15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>.  <a href="#a5c99dc290f1b17caea402f461e2ce15e">Continua...</a><br /></td></tr>
<tr class="separator:a5c99dc290f1b17caea402f461e2ce15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56b03b59e89f2bebaa6a6e5276e05f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac56b03b59e89f2bebaa6a6e5276e05f2">incomingHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const </td></tr>
<tr class="memdesc:ac56b03b59e89f2bebaa6a6e5276e05f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>.  <a href="#ac56b03b59e89f2bebaa6a6e5276e05f2">Continua...</a><br /></td></tr>
<tr class="separator:ac56b03b59e89f2bebaa6a6e5276e05f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc035e900f87314986669194ef4290be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afc035e900f87314986669194ef4290be">incidentHalfEdgeBegin</a> () const </td></tr>
<tr class="memdesc:afc035e900f87314986669194ef4290be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>.  <a href="#afc035e900f87314986669194ef4290be">Continua...</a><br /></td></tr>
<tr class="separator:afc035e900f87314986669194ef4290be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6f00429b29c51079bc613c8c7d9390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#adc6f00429b29c51079bc613c8c7d9390">incidentHalfEdgeEnd</a> () const </td></tr>
<tr class="memdesc:adc6f00429b29c51079bc613c8c7d9390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>.  <a href="#adc6f00429b29c51079bc613c8c7d9390">Continua...</a><br /></td></tr>
<tr class="separator:adc6f00429b29c51079bc613c8c7d9390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0711186d102e4350b79884e19ca670e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa0711186d102e4350b79884e19ca670e">incidentHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const </td></tr>
<tr class="memdesc:aa0711186d102e4350b79884e19ca670e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>.  <a href="#aa0711186d102e4350b79884e19ca670e">Continua...</a><br /></td></tr>
<tr class="separator:aa0711186d102e4350b79884e19ca670e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d1061148879718e3b2675d63e3b60f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ab8d1061148879718e3b2675d63e3b60f">incidentHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const </td></tr>
<tr class="memdesc:ab8d1061148879718e3b2675d63e3b60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>.  <a href="#ab8d1061148879718e3b2675d63e3b60f">Continua...</a><br /></td></tr>
<tr class="separator:ab8d1061148879718e3b2675d63e3b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23eef1ad43fed59e93a768c74a3f01a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a23eef1ad43fed59e93a768c74a3f01a7">incidentFaceBegin</a> () const </td></tr>
<tr class="memdesc:a23eef1ad43fed59e93a768c74a3f01a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>.  <a href="#a23eef1ad43fed59e93a768c74a3f01a7">Continua...</a><br /></td></tr>
<tr class="separator:a23eef1ad43fed59e93a768c74a3f01a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca9340c49adf2d11972e62d3560c904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a0ca9340c49adf2d11972e62d3560c904">incidentFaceEnd</a> () const </td></tr>
<tr class="memdesc:a0ca9340c49adf2d11972e62d3560c904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>.  <a href="#a0ca9340c49adf2d11972e62d3560c904">Continua...</a><br /></td></tr>
<tr class="separator:a0ca9340c49adf2d11972e62d3560c904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba89db98d79f03d023cfba2cbc0435a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7ba89db98d79f03d023cfba2cbc0435a">incidentFaceBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const </td></tr>
<tr class="memdesc:a7ba89db98d79f03d023cfba2cbc0435a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>.  <a href="#a7ba89db98d79f03d023cfba2cbc0435a">Continua...</a><br /></td></tr>
<tr class="separator:a7ba89db98d79f03d023cfba2cbc0435a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8832768a1592dd379b5cf7ac99a43a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af8832768a1592dd379b5cf7ac99a43a9">incidentFaceBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const </td></tr>
<tr class="memdesc:af8832768a1592dd379b5cf7ac99a43a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>.  <a href="#af8832768a1592dd379b5cf7ac99a43a9">Continua...</a><br /></td></tr>
<tr class="separator:af8832768a1592dd379b5cf7ac99a43a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15a987ee31b7012ed0d1cb51f68d66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa15a987ee31b7012ed0d1cb51f68d66f">updateNormal</a> ()</td></tr>
<tr class="memdesc:aa15a987ee31b7012ed0d1cb51f68d66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ricalcola e restituisce la normale al vertice, e aggiorna la cardinalità del vertice.  <a href="#aa15a987ee31b7012ed0d1cb51f68d66f">Continua...</a><br /></td></tr>
<tr class="separator:aa15a987ee31b7012ed0d1cb51f68d66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6909cf4a951dc2504caaeaae872fde1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af6909cf4a951dc2504caaeaae872fde1">updateCardinality</a> ()</td></tr>
<tr class="memdesc:af6909cf4a951dc2504caaeaae872fde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ricalcola e restituisce la cardinalità del vertice, ossia il numero di <b>edge</b> (non half edge!) incidenti.  <a href="#af6909cf4a951dc2504caaeaae872fde1">Continua...</a><br /></td></tr>
<tr class="separator:af6909cf4a951dc2504caaeaae872fde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c7f3495daa71a2a2b72ecde413210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a8f3c7f3495daa71a2a2b72ecde413210">findSharedHalfEdge</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *vertex)</td></tr>
<tr class="memdesc:a8f3c7f3495daa71a2a2b72ecde413210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che cerca e restituisce l'half edge condiviso dal vertice this e vertex.  <a href="#a8f3c7f3495daa71a2a2b72ecde413210">Continua...</a><br /></td></tr>
<tr class="separator:a8f3c7f3495daa71a2a2b72ecde413210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af625660c1b4ab1efee5c4c494a1d5596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af625660c1b4ab1efee5c4c494a1d5596">adjacentVertexBegin</a> ()</td></tr>
<tr class="memdesc:af625660c1b4ab1efee5c4c494a1d5596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#af625660c1b4ab1efee5c4c494a1d5596">Continua...</a><br /></td></tr>
<tr class="separator:af625660c1b4ab1efee5c4c494a1d5596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028641a4f49729dd099c62b364a6c1cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a028641a4f49729dd099c62b364a6c1cf">adjacentVertexEnd</a> ()</td></tr>
<tr class="memdesc:a028641a4f49729dd099c62b364a6c1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#a028641a4f49729dd099c62b364a6c1cf">Continua...</a><br /></td></tr>
<tr class="separator:a028641a4f49729dd099c62b364a6c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38680e4442bd79d786cc7b697cff8600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a38680e4442bd79d786cc7b697cff8600">adjacentVertexBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:a38680e4442bd79d786cc7b697cff8600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#a38680e4442bd79d786cc7b697cff8600">Continua...</a><br /></td></tr>
<tr class="separator:a38680e4442bd79d786cc7b697cff8600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89cb5c8e39ac53d35b3c3d46c904667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ad89cb5c8e39ac53d35b3c3d46c904667">adjacentVertexBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:ad89cb5c8e39ac53d35b3c3d46c904667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#ad89cb5c8e39ac53d35b3c3d46c904667">Continua...</a><br /></td></tr>
<tr class="separator:ad89cb5c8e39ac53d35b3c3d46c904667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0dc803d6d1ebd22a0e50c345e2da5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afa0dc803d6d1ebd22a0e50c345e2da5c">adjacentVertexBegin</a> (<a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start)</td></tr>
<tr class="memdesc:afa0dc803d6d1ebd22a0e50c345e2da5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#afa0dc803d6d1ebd22a0e50c345e2da5c">Continua...</a><br /></td></tr>
<tr class="separator:afa0dc803d6d1ebd22a0e50c345e2da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5748eefe944c0bde7e36c719c5721781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a5748eefe944c0bde7e36c719c5721781">adjacentVertexBegin</a> (<a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start, <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *end)</td></tr>
<tr class="memdesc:a5748eefe944c0bde7e36c719c5721781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#a5748eefe944c0bde7e36c719c5721781">Continua...</a><br /></td></tr>
<tr class="separator:a5748eefe944c0bde7e36c719c5721781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ad4d92f2a1dabea8dba215858794b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a51ad4d92f2a1dabea8dba215858794b5">outgoingHalfEdgeBegin</a> ()</td></tr>
<tr class="memdesc:a51ad4d92f2a1dabea8dba215858794b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>.  <a href="#a51ad4d92f2a1dabea8dba215858794b5">Continua...</a><br /></td></tr>
<tr class="separator:a51ad4d92f2a1dabea8dba215858794b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d3e433d920cf11566efdd50d3043fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ad4d3e433d920cf11566efdd50d3043fa">outgoingHalfEdgeEnd</a> ()</td></tr>
<tr class="memdesc:ad4d3e433d920cf11566efdd50d3043fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>.  <a href="#ad4d3e433d920cf11566efdd50d3043fa">Continua...</a><br /></td></tr>
<tr class="separator:ad4d3e433d920cf11566efdd50d3043fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa818fa51cc350dd63e3b16666339632d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa818fa51cc350dd63e3b16666339632d">outgoingHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:aa818fa51cc350dd63e3b16666339632d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>.  <a href="#aa818fa51cc350dd63e3b16666339632d">Continua...</a><br /></td></tr>
<tr class="separator:aa818fa51cc350dd63e3b16666339632d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521ec35b8c0bf0fc04ccda8daaf0b1ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a521ec35b8c0bf0fc04ccda8daaf0b1ec">outgoingHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:a521ec35b8c0bf0fc04ccda8daaf0b1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>.  <a href="#a521ec35b8c0bf0fc04ccda8daaf0b1ec">Continua...</a><br /></td></tr>
<tr class="separator:a521ec35b8c0bf0fc04ccda8daaf0b1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2520372b90e7700f1c3ad5efcf86485c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a2520372b90e7700f1c3ad5efcf86485c">incomingHalfEdgeBegin</a> ()</td></tr>
<tr class="memdesc:a2520372b90e7700f1c3ad5efcf86485c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>.  <a href="#a2520372b90e7700f1c3ad5efcf86485c">Continua...</a><br /></td></tr>
<tr class="separator:a2520372b90e7700f1c3ad5efcf86485c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacd416c59aef198db8fa8507fa43b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aeacd416c59aef198db8fa8507fa43b11">incomingHalfEdgeEnd</a> ()</td></tr>
<tr class="memdesc:aeacd416c59aef198db8fa8507fa43b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>.  <a href="#aeacd416c59aef198db8fa8507fa43b11">Continua...</a><br /></td></tr>
<tr class="separator:aeacd416c59aef198db8fa8507fa43b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb79cd6f3e85146eac1ecd7bae72cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afcb79cd6f3e85146eac1ecd7bae72cf0">incomingHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:afcb79cd6f3e85146eac1ecd7bae72cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>.  <a href="#afcb79cd6f3e85146eac1ecd7bae72cf0">Continua...</a><br /></td></tr>
<tr class="separator:afcb79cd6f3e85146eac1ecd7bae72cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572ed133e758f8c9c7744b9a4947b037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a572ed133e758f8c9c7744b9a4947b037">incomingHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:a572ed133e758f8c9c7744b9a4947b037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>.  <a href="#a572ed133e758f8c9c7744b9a4947b037">Continua...</a><br /></td></tr>
<tr class="separator:a572ed133e758f8c9c7744b9a4947b037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f1a9cf6aefb84daca8768c74471c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a90f1a9cf6aefb84daca8768c74471c72">incidentHalfEdgeBegin</a> ()</td></tr>
<tr class="memdesc:a90f1a9cf6aefb84daca8768c74471c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>.  <a href="#a90f1a9cf6aefb84daca8768c74471c72">Continua...</a><br /></td></tr>
<tr class="separator:a90f1a9cf6aefb84daca8768c74471c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a94f4290722b3b5e635170a42976a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a68a94f4290722b3b5e635170a42976a5">incidentHalfEdgeEnd</a> ()</td></tr>
<tr class="memdesc:a68a94f4290722b3b5e635170a42976a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>.  <a href="#a68a94f4290722b3b5e635170a42976a5">Continua...</a><br /></td></tr>
<tr class="separator:a68a94f4290722b3b5e635170a42976a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f34fdd1b9fbc78f27cfcc7b8d91e11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac8f34fdd1b9fbc78f27cfcc7b8d91e11">incidentHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:ac8f34fdd1b9fbc78f27cfcc7b8d91e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>.  <a href="#ac8f34fdd1b9fbc78f27cfcc7b8d91e11">Continua...</a><br /></td></tr>
<tr class="separator:ac8f34fdd1b9fbc78f27cfcc7b8d91e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ca1be7938dec64f0008eef461622bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af7ca1be7938dec64f0008eef461622bb">incidentHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:af7ca1be7938dec64f0008eef461622bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>.  <a href="#af7ca1be7938dec64f0008eef461622bb">Continua...</a><br /></td></tr>
<tr class="separator:af7ca1be7938dec64f0008eef461622bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15c9bc16b4d82ec9fbac027b43f3f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ae15c9bc16b4d82ec9fbac027b43f3f15">incidentFaceBegin</a> ()</td></tr>
<tr class="memdesc:ae15c9bc16b4d82ec9fbac027b43f3f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>.  <a href="#ae15c9bc16b4d82ec9fbac027b43f3f15">Continua...</a><br /></td></tr>
<tr class="separator:ae15c9bc16b4d82ec9fbac027b43f3f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7884f95c62825149bc2c8a09844219"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a6c7884f95c62825149bc2c8a09844219">incidentFaceEnd</a> ()</td></tr>
<tr class="memdesc:a6c7884f95c62825149bc2c8a09844219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>.  <a href="#a6c7884f95c62825149bc2c8a09844219">Continua...</a><br /></td></tr>
<tr class="separator:a6c7884f95c62825149bc2c8a09844219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dd8578f18308f9d111919935596727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a37dd8578f18308f9d111919935596727">incidentFaceBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:a37dd8578f18308f9d111919935596727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>.  <a href="#a37dd8578f18308f9d111919935596727">Continua...</a><br /></td></tr>
<tr class="separator:a37dd8578f18308f9d111919935596727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1699e2df8c65baf04b7ed3fbc7293d14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a1699e2df8c65baf04b7ed3fbc7293d14">incidentFaceBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:a1699e2df8c65baf04b7ed3fbc7293d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>.  <a href="#a1699e2df8c65baf04b7ed3fbc7293d14">Continua...</a><br /></td></tr>
<tr class="separator:a1699e2df8c65baf04b7ed3fbc7293d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Membri protetti</h2></td></tr>
<tr class="memitem:ab472df61b8c1c5671cea2367d837cdc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ab472df61b8c1c5671cea2367d837cdc6">setId</a> (unsigned int <a class="el" href="classDcel_1_1Vertex.html#ac7bc1e3501db91019ccf165639e8f243">id</a>)</td></tr>
<tr class="memdesc:ab472df61b8c1c5671cea2367d837cdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta l'id del vertice.  <a href="#ab472df61b8c1c5671cea2367d837cdc6">Continua...</a><br /></td></tr>
<tr class="separator:ab472df61b8c1c5671cea2367d837cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Attributi protetti</h2></td></tr>
<tr class="memitem:a6a1d4109ed7c63f1c6d2053443e79125"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a1d4109ed7c63f1c6d2053443e79125"></a>
<a class="el" href="classPoint.html">Pointd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a6a1d4109ed7c63f1c6d2053443e79125">coordinate</a></td></tr>
<tr class="memdesc:a6a1d4109ed7c63f1c6d2053443e79125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Punto nello spazio 3D rappresentante la posizione del vertice. <br /></td></tr>
<tr class="separator:a6a1d4109ed7c63f1c6d2053443e79125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d86451c230608f56136e98917f22140"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d86451c230608f56136e98917f22140"></a>
<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a5d86451c230608f56136e98917f22140">incidentHalfEdge</a></td></tr>
<tr class="memdesc:a5d86451c230608f56136e98917f22140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uno degli half edge uscenti incidenti sul vertice. <br /></td></tr>
<tr class="separator:a5d86451c230608f56136e98917f22140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e6c8f4a2c38095f8b019185d798fb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30e6c8f4a2c38095f8b019185d798fb9"></a>
<a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a30e6c8f4a2c38095f8b019185d798fb9">normal</a></td></tr>
<tr class="memdesc:a30e6c8f4a2c38095f8b019185d798fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vettore normale al vertice. <br /></td></tr>
<tr class="separator:a30e6c8f4a2c38095f8b019185d798fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532c8cd4a47dc77aa49142d74024a964"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a532c8cd4a47dc77aa49142d74024a964"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a532c8cd4a47dc77aa49142d74024a964">cardinality</a></td></tr>
<tr class="memdesc:a532c8cd4a47dc77aa49142d74024a964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numero di edge (metà degli half edge) incidenti sul vertice. <br /></td></tr>
<tr class="separator:a532c8cd4a47dc77aa49142d74024a964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bc1e3501db91019ccf165639e8f243"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7bc1e3501db91019ccf165639e8f243"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac7bc1e3501db91019ccf165639e8f243">id</a></td></tr>
<tr class="memdesc:ac7bc1e3501db91019ccf165639e8f243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Id univoco, all'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, associato al vertice. <br /></td></tr>
<tr class="separator:ac7bc1e3501db91019ccf165639e8f243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29ca6ca3f89c5a48f5f52f86841ab31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae29ca6ca3f89c5a48f5f52f86841ab31"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ae29ca6ca3f89c5a48f5f52f86841ab31">flag</a></td></tr>
<tr class="memdesc:ae29ca6ca3f89c5a48f5f52f86841ab31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag personalizzabile, associato al vertice. <br /></td></tr>
<tr class="separator:ae29ca6ca3f89c5a48f5f52f86841ab31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friend</h2></td></tr>
<tr class="memitem:aa1fcaa71081ba7020ce73fec523e4d9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1fcaa71081ba7020ce73fec523e4d9b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Dcel</b></td></tr>
<tr class="separator:aa1fcaa71081ba7020ce73fec523e4d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<div class="textblock"><p>Classe rappresentante un vertice della DCEL. </p>
<p>All'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, le sue componenti fondamentali sono:</p><ul>
<li>coordinate: Pointd contenente la posizione in uno spazio 3D del vertice; <br />
</li>
<li>incicentHalfEdge: uno degli half edge <b>uscenti</b> incidenti al vertice, ossia half edge che ha come from vertex il vertice stesso. <br />
</li>
</ul>
<p>Per una corretta gestione della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, ogni <a class="el" href="classDcel_1_1Vertex.html" title="Classe rappresentante un vertice della DCEL. ">Dcel::Vertex</a> <code>v</code> deve avere un <code>incidentHalfEdge</code>. Tale halfEdge deve avere come fromVertex il vertice <code>v</code>, e il suo twin deve avere <code>v</code> come toVertex. Devono poi essere rispettate le regole degli halfEdge e dei loro vertici incidenti sulle relazioni di prev e next.</p>
<p>Le altre componenti che compongono il vertice sono:</p><ul>
<li>normal: vettore 3D rappresentante la normale del vertice, che solitamente è la media delle normali delle facce incidenti;<br />
</li>
<li>cardinality: numero di edge (ossia la metà del numero di half edge) incidenti sul vertice;<br />
</li>
<li>id: intero senza segno univoco all'interno della lista dei vertici della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, non modificabile dall'utente. Può essere usato per identificare il vertice all'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> (in modo meno efficiente rispetto all'utilizzo di un puntatore);<br />
</li>
<li>flag: intero personalizzabile dall'utente. <br />
</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Da fare:</a></b></dt><dd>color: colore associato al vertice;<br />
</dd></dl>
<dl class="section author"><dt>Autore</dt><dd>Alessandro Muntoni (<a href="#" onclick="location.href='mai'+'lto:'+'mun'+'to'+'ni.'+'al'+'ess'+'an'+'dro'+'@g'+'mai'+'l.'+'com'; return false;">munto<span style="display: none;">.nosp@m.</span>ni.a<span style="display: none;">.nosp@m.</span>lessa<span style="display: none;">.nosp@m.</span>ndro<span style="display: none;">.nosp@m.</span>@gmai<span style="display: none;">.nosp@m.</span>l.co<span style="display: none;">.nosp@m.</span>m</a>) </dd></dl>
</div><h2 class="groupheader">Documentazione dei costruttori e dei distruttori</h2>
<a class="anchor" id="a2da229e7ef9443810ec4f61da9a33e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::Vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea un vertice con:</p><ul>
<li>posizione pari a (0, 0, 0);</li>
<li>half edge incidente settato a nullptr;</li>
<li>vettore normale pari a (0, 0, 0);</li>
<li>cardinalità pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad3da5e567cfaf3d1d4c9a3dfecf13564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::Vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Pointd</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea un vertice con:</p><ul>
<li>posizione pari al parametro in input p;</li>
<li>half edge incidente settato a nullptr;</li>
<li>vettore normale pari a (0, 0, 0);</li>
<li>cardinalità pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0.</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Poind rappresentante la posizione assegnata al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31aaedc4b3477ed85390daa341f3976e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::Vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Pointd</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>halfEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea un vertice con:</p><ul>
<li>posizione pari al parametro in input p;</li>
<li>half edge incidente pari al parametro in input halfEdge;</li>
<li>vettore normale pari a (0, 0, 0);</li>
<li>cardinalità pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0.</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Poind rappresentante la posizione assegnata al vertice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halfEdge</td><td>puntatore all'half edge incidente assegnato al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58eb006d5da7901f5cbc5f103e919a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::Vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Pointd</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>halfEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cardinality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea un vertice con:</p><ul>
<li>posizione pari al parametro in input p;</li>
<li>half edge incidente pari al parametro in input halfEdge;</li>
<li>vettore normale pari a (0, 0, 0);</li>
<li>cardinalità pari al parametro in input cardinality;</li>
<li>id pari a 0;</li>
<li>flag pari a 0.</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Poind rappresentante la posizione assegnata al vertice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halfEdge</td><td>puntatore all'half edge incidente assegnato al vertice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cardinality</td><td>cardinalità settata al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f736bd9320adb06315ba1c7a12f1f87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::~Vertex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distruttore vuoto. </p>
<p>La classe <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> dovrà occuparsi di eliminare tutti i riferimenti in essa contenuti (e quindi contenuti di conseguenza anche nella classe <a class="el" href="classDcel_1_1Vertex.html" title="Classe rappresentante un vertice della DCEL. ">Dcel::Vertex</a>). </p>

</div>
</div>
<h2 class="groupheader">Documentazione delle funzioni membro</h2>
<a class="anchor" id="ac67907af93aecf1439b371add6cfc789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'incidentHalfEdge </dd></dl>

</div>
</div>
<a class="anchor" id="a9976abbc083b7f343df09755639c4a6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromoVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="afab0fbec7249bcbd5d0be2a4551fd91c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'half edge start e fino al toVertex dell'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, il cui toVertex <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromoVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a92e9d5250d0248081d579fc8807272b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal vertice start.<br />
È meno efficiente rispetto a Dcel::Vertex::constAdjacentVertexBegin(const Dcel::HalfEdge* start).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere adiacente al vertice this (ossia non esiste un half edge condiviso tra this e start), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality(start))</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aedef3b927ff65391da2a19be06b0bb7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal vertice start e fino al vertice end.<br />
È meno efficiente rispetto a Dcel::Vertex::constAdjacentVertexBegin(const Dcel::HalfEdge* start, const Dcel::HalfEdge* end).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>vertice di arrivo, <b>non</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere adiacenti al vertice this (ossia non esiste un half edge condiviso tra this e start e tra this e end), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality(start))</em> + <em>O(Cardinality(end))</em> </dd></dl>

</div>
</div>
<a class="anchor" id="af625660c1b4ab1efee5c4c494a1d5596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'incidentHalfEdge </dd></dl>

</div>
</div>
<a class="anchor" id="a38680e4442bd79d786cc7b697cff8600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromoVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="ad89cb5c8e39ac53d35b3c3d46c904667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'half edge start e fino al toVertex dell'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, il cui toVertex <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromoVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="afa0dc803d6d1ebd22a0e50c345e2da5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal vertice start.<br />
È meno efficiente rispetto a Dcel::Vertex::constAdjacentVertexBegin(const Dcel::HalfEdge* start).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere adiacente al vertice this (ossia non esiste un half edge condiviso tra this e start), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality(start))</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a5748eefe944c0bde7e36c719c5721781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal vertice start e fino al vertice end.<br />
È meno efficiente rispetto a Dcel::Vertex::constAdjacentVertexBegin(const Dcel::HalfEdge* start, const Dcel::HalfEdge* end).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>vertice di arrivo, <b>non</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere adiacenti al vertice this (ossia non esiste un half edge condiviso tra this e start e tra this e end), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality(start))</em> + <em>O(Cardinality(end))</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aa0034fe1f7a6225950d1c6a0a6f9ffc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="a028641a4f49729dd099c62b364a6c1cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="adc0756749e0c536697faf1ae826d133d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::decrementCardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrementa la cardinalità del vertice (se essa è maggiore di 0) </p>
<dl class="section return"><dt>Restituisce</dt><dd>La cardinalità decrementata </dd></dl>

</div>
</div>
<a class="anchor" id="a12f71d2e2ae4a12b34dd155c7e85a3d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Dcel::Vertex::dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>otherVertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calcola e restituisce la distanza tra il vertice this e il vertice in input. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVertex</td><td>vertice con cui verrà calcolata la distanza dal vertice this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>La distanza tra il vertice this e otherVertex </dd></dl>

</div>
</div>
<a class="anchor" id="a7af03f5188824f4dacc0652eb52aabed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Vertex::findSharedHalfEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che cerca e restituisce l'half edge costante condiviso dal vertice this e vertex. </p>
<p>Nello specifico, se viene cercato l'half edge che ha come origine il vertice this e come destinazione il vertice in input vertex. Se l'half edge non viene trovato (non esiste un half edge condiviso dai due vertici) viene restituito nullptr;</p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> </dd></dl>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>vertice con cui viene cercato l'half edge condiviso </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>l'half edge condiviso se esiste, nullptr altrimenti </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f3c7f3495daa71a2a2b72ecde413210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Vertex::findSharedHalfEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che cerca e restituisce l'half edge condiviso dal vertice this e vertex. </p>
<p>Nello specifico, se viene cercato l'half edge che ha come origine il vertice this e come destinazione il vertice in input vertex. Se l'half edge non viene trovato (non esiste un half edge condiviso dai due vertici) viene restituito nullptr;</p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a> </dd></dl>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>vertice con cui viene cercato l'half edge condiviso </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>l'half edge condiviso se esiste, nullptr altrimenti </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a20318e5baac00d992e7a98c46d19d7ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getCardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il numero di edge incidenti sul vertice. </p>
<dl class="section note"><dt>Nota</dt><dd>Non ricalcola la cardinalità, restituisce solo l'ultima cardinalità calcolata o settata </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La cardinalità del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a955f92ea4027d02503c7714de9af742b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Pointd</a> Dcel::Vertex::getCoordinate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce le coordinate del vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Pointd rappresentante la posizione nello spazio del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="adb7de167d0c3c9ce68a771506ed75d76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il flag associato al vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Il flag del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="ac2aa7c2ed2b5a65a46a5411cd567e7ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Dcel::Vertex::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restirìtuisce l'id identificativo nella <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> del vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'id del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a9d809eb8575c715b32d51f5bb5393354"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Vertex::getIncidentHalfEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il puntatore l'half edge costante incidente sul vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'<a class="el" href="classDcel_1_1HalfEdge.html" title="Classe rappresentante un half edge della Dcel. ">HalfEdge</a> incidente sul vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a0a949ee8a2fcace2c112238586f13daf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Vertex::getIncidentHalfEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il puntatore all'half edge incidente sul vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'<a class="el" href="classDcel_1_1HalfEdge.html" title="Classe rappresentante un half edge della Dcel. ">HalfEdge</a> incidente sul vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a6886ddfb802b2411fe4b02ff35fa2e2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Vec3</a> Dcel::Vertex::getNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il vettore normale al vertice. </p>
<dl class="section note"><dt>Nota</dt><dd>Non ricalcola la normale, restituisce solo l'ultima normale calcolata o settata </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La normale al vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a238513dc5c1abcba58c9c1bdcc2e0db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getNumberAdjacentVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcola e restituisce il numero di vertici adiacenti al vertice. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di vertici adiacenti al vertice </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a class="anchor" id="afb3ab6e9eff11e64e01369ee2c7d2f6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getNumberIncidentFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcola e restituisce il numero di facce incidenti sul vertice. </p>
<dl class="section note"><dt>Nota</dt><dd>Se un'unica faccia incide sul vertice due volte, questa verrà contata due volte </dd></dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di facce incidenti sul vertice </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ade5950ee3f62f57974b4a683d812e230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getNumberIncidentHalfEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcola e restituisce il numero di half edge (non di edge) incidenti sul vertice. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di edge incidenti sul vertice </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a23eef1ad43fed59e93a768c74a3f01a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">Dcel::Vertex::ConstIncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a7ba89db98d79f03d023cfba2cbc0435a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">Dcel::Vertex::ConstIncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="af8832768a1592dd379b5cf7ac99a43a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">Dcel::Vertex::ConstIncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'half edge start e fino alla faccia incidente sull'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="ae15c9bc16b4d82ec9fbac027b43f3f15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">Dcel::Vertex::IncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a37dd8578f18308f9d111919935596727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">Dcel::Vertex::IncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a1699e2df8c65baf04b7ed3fbc7293d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">Dcel::Vertex::IncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'half edge start e fino alla faccia incidente sull'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a0ca9340c49adf2d11972e62d3560c904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">Dcel::Vertex::ConstIncidentFaceIterator</a> Dcel::Vertex::incidentFaceEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="a6c7884f95c62825149bc2c8a09844219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">Dcel::Vertex::IncidentFaceIterator</a> Dcel::Vertex::incidentFaceEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="afc035e900f87314986669194ef4290be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti, sia uscenti che entranti nel vertice, partendo dall'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="aa0711186d102e4350b79884e19ca670e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti e entranti nel vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come toVertex o fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="ab8d1061148879718e3b2675d63e3b60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti e entranti nel vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come toVertex o fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a90f1a9cf6aefb84daca8768c74471c72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">Dcel::Vertex::IncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti, sia uscenti che entranti nel vertice, partendo dall'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f34fdd1b9fbc78f27cfcc7b8d91e11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">Dcel::Vertex::IncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti e entranti nel vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come toVertex o fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="af7ca1be7938dec64f0008eef461622bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">Dcel::Vertex::IncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti e entranti nel vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come toVertex o fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="adc6f00429b29c51079bc613c8c7d9390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="a68a94f4290722b3b5e635170a42976a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">Dcel::Vertex::IncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="a112e7a8607dcee8f8bfc286cba7765d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dal twin dell'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al twin dell'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a5c99dc290f1b17caea402f461e2ce15e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come toVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="ac56b03b59e89f2bebaa6a6e5276e05f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come toVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a2520372b90e7700f1c3ad5efcf86485c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">Dcel::Vertex::IncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dal twin dell'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al twin dell'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="afcb79cd6f3e85146eac1ecd7bae72cf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">Dcel::Vertex::IncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come toVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a572ed133e758f8c9c7744b9a4947b037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">Dcel::Vertex::IncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come toVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="abb497fcab1ac5e9ab2ccadbabed10c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="aeacd416c59aef198db8fa8507fa43b11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">Dcel::Vertex::IncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="a7d8c450e431fd8babcdb7cfdf517b8fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::incrementCardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Incrementa la cardinalità del vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>La cardinalità incrementata </dd></dl>

</div>
</div>
<a class="anchor" id="a7bf34479e1a7c60b032e45b62fdf5145"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Vertex::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>othervertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operatore di disuguaglianza tra vertici. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVertex</td><td>vertice con cui verrà verificata la disuguaglianza con la faccia this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>True se i vertici sono diversi, false altrimenti </dd></dl>

</div>
</div>
<a class="anchor" id="a6d164730ab1cb90d87f80c43ac25bc4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Vertex::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>otherVertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operatore di uguaglianza tra vertici. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVertex</td><td>vertice con cui verrà verificata l'uguaglianza con la faccia this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>True se i vertici sono uguali, false altrimenti </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Da fare:</a></b></dt><dd>Da riscrivere </dd></dl>

</div>
</div>
<a class="anchor" id="acec54a206474159f5fbb91eaca3fca9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="a2eb09e3d8ec23f60ddc83b6cf1397de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a67b0c5d03b6fb48c1d4deb997601aab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a51ad4d92f2a1dabea8dba215858794b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">Dcel::Vertex::OutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a class="anchor" id="aa818fa51cc350dd63e3b16666339632d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">Dcel::Vertex::OutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a521ec35b8c0bf0fc04ccda8daaf0b1ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">Dcel::Vertex::OutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a class="anchor" id="a79e864a3d65ecfcefc12f9a623ab422c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d3e433d920cf11566efdd50d3043fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">Dcel::Vertex::OutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a class="anchor" id="a9e6c739192c444e8965949e79041c1d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setCardinality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newCardinality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta la cardinalità del vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newCardinality</td><td>la cardinalitù che verrà settata </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9711522bca5e434f38a4dd693472017c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setCoordinate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Pointd</a> &amp;&#160;</td>
          <td class="paramname"><em>newCoordinate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta le coordinate del vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newCoordinate</td><td>il punto che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1478717bb5e45383acc6531c420dd57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta il flag del vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newFlag</td><td>il valore del flag che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab472df61b8c1c5671cea2367d837cdc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta l'id del vertice. </p>
<p>Questa funzione dovrebbe essere chiamata solamente dalla classe <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>nuovo id che verrà assegnato al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c4e583a30166edb3cac283bb60b4191"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setIncidentHalfEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>newIncidentHalfEdge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assegna un nuovo half edge incidente al vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newIncidentHalfEdge</td><td>puntatore all'half edge incidente assegnato al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b7e992ed35ffdfdc24b37f8d6fc2386"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>newNormal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta il vettore normale al vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newNormal</td><td>il vettore normale che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d8e18f8229b78cf20a99adfa5b0a5b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dcel::Vertex::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione toString di un vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Una stringa rappresentativa del vertice </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Da fare:</a></b></dt><dd>Da aggiornare </dd></dl>

</div>
</div>
<a class="anchor" id="af6909cf4a951dc2504caaeaae872fde1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Dcel::Vertex::updateCardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ricalcola e restituisce la cardinalità del vertice, ossia il numero di <b>edge</b> (non half edge!) incidenti. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La cardinalità del vertice appena calcolata </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aa15a987ee31b7012ed0d1cb51f68d66f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Vec3</a> Dcel::Vertex::updateNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ricalcola e restituisce la normale al vertice, e aggiorna la cardinalità del vertice. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La normale al vertice appena calcolata </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<hr/>La documentazione per questa classe è stata generata a partire dai seguenti file:<ul>
<li><a class="el" href="dcel__vertex_8h_source.html">dcel_vertex.h</a></li>
<li>dcel_vertex.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classDcel.html">Dcel</a></li><li class="navelem"><a class="el" href="classDcel_1_1Vertex.html">Vertex</a></li>
    <li class="footer">Generato da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
